# 要件整理・補足

## 1. Must（必須要件）

### BGMミックス自動生成エンジン（Python＋pydub 等）
- 「心の色」やストレスレベルの数値化／タグ化を具体化することで、ミックスロジック設計が明確になる。
- pydub だけでなく、軽量なストリーミング向けには ffmpeg 直接呼び出しや soundfile／numpy 併用も検討するとパフォーマンス向上につながる。
- 音源ごとにサンプリングレートやチャンネル数が異なるとミックス時にノイズが出るため、事前正規化（モノラル化やリサンプリング）フローを設計する。

### ストリーミング配信機能
- WebSocket／HTTP Live Streaming（HLS）など、リアルタイム再生方式を決めておくとクライアント実装が安定する。
- 低レイテンシ重視なら WebRTC、安定性重視なら HLS／DASH を使い分けるアーキテクチャもあり得る。
- 帯域や同時接続数を見越したストリーミングサーバ（NGINX RTMP モジュールや Kurento など）の選定を早めに行うと安心。

---

## 2. Should（推奨要件）

### リアルタイム天気情報連携
- まずは「現在の天気」を取得する基本実装を行い、後から「1時間ごと」や「天気が変わったら」の動的再生成を追加するとスムーズ。
- OpenWeather API のコール制限に注意し、キャッシュ層（Redis）を入れて不要リクエストを削減する。

---

## 3. Could（任意要件）

### セッション保持／スケーラビリティ設計
- ユーザーごとに「最後に生成したミックス」「選択した心の色回答」をキャッシュしておき、再アクセス時のレスポンスを高速化できる。
- APIサーバとストリーミングサーバを分離し、ステートレスな設計でオートスケールさせると負荷に強くなる。

### ワークフローのキューイング（Celery 等）
- 生成処理を非同期タスクにすることで、「天気変化時」「セッション更新時」に自動的にリミックスをキューに流せる。
- タスク結果を S3 などにアップロードして、URL をクライアントに返す方式にすると、ストリーミング負荷をさらに最適化できる。

### ストレス推定の高度化
- 現在は“心の色”→スコアというルックアップ型だが、将来的に単語ベースの自然言語解析（簡易なキーワード出現頻度）や機械学習モデルを組み込むと、よりパーソナライズできる。

---

## 4. Won’t（除外要件）

- ソーシャル／モバイルネイティブは現フェーズで除外 OK。
- ただし「将来ユーザ拡大して外部シェア機能を追加したい」「Flutter でアプリ化したい」といったロードマップだけは軽く残しておくと、開発優先度がぶれない。

---

## 5. 次フェーズの検討ポイント

### API 仕様書
- ユーザー設定→ストレス推定→ミックス生成→ストリーミングの各エンドポイントを OpenAPI で定義。

### インフラ／運用
- 音声ファイルの保存先、CDN 経由での配信、監視（Prometheus＋Grafana）も早期に計画を。

### UX／UI 設計
- 「心の色」を選ぶ画面のデザインや、再生中に気分に合わせてボリュームを微調整できるスライダーなど、ユーザー体験を固めると差別化になる。

### テスト戦略
- ミックス結果の品質評価は自動テストしづらいため、ユーザーアンケートや A/B テストの仕組みを組み込むと改善サイクルが速くなる。

全体として、Must／Should／Could が適切に分かれており、段階的に実装しやすい構成になっています。上記のような運用・品質・拡張性の観点を追加で詰めていくと、より確実にプロダクト化できるかと思います。何か追加で深掘りしたい項目があれば教えてください！